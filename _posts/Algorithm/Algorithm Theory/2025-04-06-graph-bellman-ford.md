---
title: "[ì•Œê³ ë¦¬ì¦˜] ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜(Bellman-Ford Algorithm) êµ¬í˜„(C++, Python)"
date: 2025-04-06 16:00:00 +0900
last_modified_at: 2025-04-06 16:00:00 +0900
categories:
  - Algorithm Theory
tags:
  - graph
  - algorithm
  - coding test
  - graph implementation
  - bellman-ford

toc: true
toc_sticky: true
---

## 1. ðŸ” ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜(Bellman-Ford Algorithm)

> ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ ë…¸ë“œì—ì„œ ë…¸ë“œê¹Œì§€ì˜ ìµœì†Œ ë¹„ìš©ì„ êµ¬í•œë‹¤ëŠ” ì ì—ì„œ ê°™ì§€ë§Œ, ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜ì€ ë§¤ ë‹¨ê³„ë§ˆë‹¤ ëª¨ë“  ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ë¥¼ ë‹¤ì‹œ í™•ì¸í•˜ì—¬ ìµœì†Œ ë¹„ìš©ì„ ê°±ì‹ í•˜ë¯€ë¡œ ìŒì˜ ê°€ì¤‘ì¹˜ë¥¼ ê°€ì§€ëŠ” ê·¸ëž˜í”„ì—ì„œë„ ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•  ìˆ˜ ìžˆë‹¤.

## 2. ðŸ’¡ ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜ ë™ìž‘ ê³¼ì •

1. ì‹œìž‘ ë…¸ë“œë¥¼ ì„¤ì •í•œ ë‹¤ìŒ ì‹œìž‘ ë…¸ë“œì˜ ìµœì†Œ ë¹„ìš©ì€ 0, ë‚˜ë¨¸ì§€ ë…¸ë“œëŠ” INFë¡œ ì´ˆê¸°í™”í•œë‹¤. ì´í›„ ìµœì†Œ ë¹„ìš©ì„ ê°±ì‹ í•  ë•Œ ì§ì „ ë…¸ë“œë„ ê°±ì‹ í•œë‹¤.
2. ë…¸ë“œ ê°œìˆ˜ - 1ë§Œí¼ ë‹¤ìŒ ì—°ì‚°ì„ ë°˜ë³µí•œë‹¤.
	1. ì‹œìž‘ ë…¸ë“œì—ì„œ ê°ˆ ìˆ˜ ìžˆëŠ” ê° ë…¸ë“œì— ëŒ€í•˜ì—¬ ì „ì²´ ë…¸ë“œ ê°ê°ì„ ê±°ì³ê°ˆ ë•Œ í˜„ìž¬ê¹Œì§€ êµ¬í•œ ìµœì†Œ ë¹„ìš©ë³´ë‹¤ ë” ì ì€ ìµœì†Œ ë¹„ìš©ì´ ìžˆëŠ”ì§€ í™•ì¸í•˜ì—¬ ê°±ì‹ í•œë‹¤. ìµœì†Œ ë¹„ìš©ì„ ê°±ì‹ í•  ë•Œ, Vì˜ ì§ì „ ë…¸ë“œ ê°’ë„ ê°™ì´ ê°±ì‹ í•œë‹¤.
3. ê³¼ì • 2-1ì„ ë§ˆì§€ë§‰ìœ¼ë¡œ í•œ ë²ˆ ë” ìˆ˜í–‰í•˜ì—¬ ê°±ì‹ ë˜ëŠ” ìµœì†Œ ë¹„ìš©ì´ ìžˆëŠ”ì§€ í™•ì¸í•œë‹¤. **ë§Œì•½ ìžˆë‹¤ë©´ ìŒì˜ ìˆœí™˜ì´ ìžˆìŒì„ ì˜ë¯¸í•œë‹¤.**

## 3. âš ï¸ ê³ ë ¤ ì‚¬í•­

- **ìŒì˜ ìˆœí™˜ì´ ì¡´ìž¬í•˜ë©´ ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ ìµœì†Œ ë¹„ìš©ì„ êµ¬í•  ìˆ˜ ì—†ë‹¤.**

## 4. ðŸŽ¨ ê·¸ë¦¼ê³¼ í•¨ê»˜ ì•Œê³ ë¦¬ì¦˜ ìƒê°í•´ë³´ê¸°

> ì˜ˆì‹œ ê·¸ë¦¼ê³¼ í•¨ê»˜ ì•Œê³ ë¦¬ì¦˜ì„ ìƒê°í•´ë³´ìž.

- 1ë‹¨ê³„: ìš°ì„  ì‹œìž‘ ë…¸ë“œë¥¼ Aë¡œ ì •í•˜ê³  ìµœì†Œ ë¹„ìš©ì„ 0, ì§ì „ ë…¸ë“œë¥¼ A, ë‚˜ë¨¸ì§€ ë…¸ë“œëŠ” INFë¡œ ì´ˆê¸°í™”í•œë‹¤.
- 2ë‹¨ê³„: ë…¸ë“œ Aì—ì„œ Aë¥¼ ê±°ì³ ê° ë…¸ë“œ B, C, D, Eê¹Œì§€ ê°€ëŠ” ë¹„ìš© ì¤‘ í˜„ìž¬ê¹Œì§€ êµ¬í•œ ìµœì†Œ ë¹„ìš©ë³´ë‹¤ ì ì€ ê°’ì´ ìžˆëŠ”ì§€ í™•ì¸í•˜ê³  í˜„ìž¬ê¹Œì§€ êµ¬í•œ ìµœì†Œ ë¹„ìš©ë³´ë‹¤ ë¹„ìš©ì´ ì ë‹¤ë©´ ê°±ì‹ í•œë‹¤. **ê°„ì„ ì´ ì—†ëŠ” ê²½ìš°ëŠ” INFë¡œ ê³„ì‚°í•œë‹¤.**
  - ë…¸ë“œ A ê¸°ì¤€ìœ¼ë¡œ ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.
    - A ìµœì†Œ ë¹„ìš©: ê°±ì‹ í•˜ì§€ ì•ŠìŒ(0 + 0)
    - B ìµœì†Œ ë¹„ìš©: INFì—ì„œ 4ë¡œ ê°±ì‹ (0 + 4)
    - C ìµœì†Œ ë¹„ìš©: INFì—ì„œ 3ìœ¼ë¡œ ê°±ì‹ (0 + 3)
    - D ìµœì†Œ ë¹„ìš©: ê°±ì‹ í•˜ì§€ ì•ŠìŒ(0 + INF)
    - E ìµœì†Œ ë¹„ìš©: INFì—ì„œ -6ìœ¼ë¡œ ê°±ì‹ (0 + -6)
- 3ë‹¨ê³„: ë…¸ë“œ Aì—ì„œ Bë¥¼ ê±°ì³ ê° ë…¸ë“œê¹Œì§€ ê°€ëŠ” ìµœì†Œ ë¹„ìš©ë„ ê°±ì‹ í•œë‹¤.
  - A ìµœì†Œ ë¹„ìš©: ê°±ì‹ í•˜ì§€ ì•ŠìŒ(4 + INF)
  - B ìµœì†Œ ë¹„ìš©: ê°±ì‹ í•˜ì§€ ì•ŠìŒ(4 + 0)
  - C ìµœì†Œ ë¹„ìš©: ê°±ì‹ í•˜ì§€ ì•ŠìŒ(4 + INF)
  - D ìµœì†Œ ë¹„ìš©: INFì—ì„œ 9ë¡œ ê°±ì‹ (4 + 5)
  - E ìµœì†Œ ë¹„ìš©: ê°±ì‹ í•˜ì§€ ì•ŠìŒ(4 + INF)
- 4ë‹¨ê³„: ë…¸ë“œ Aì—ì„œ Cë¥¼ ê±°ì³ ê° ë…¸ë“œê¹Œì§€ ê°€ëŠ” ìµœì†Œ ë¹„ìš©ë„ ê°±ì‹ í•œë‹¤.
  - A ìµœì†Œ ë¹„ìš©: ê°±ì‹ í•˜ì§€ ì•ŠìŒ(3 + INF)
  - B ìµœì†Œ ë¹„ìš©: ê°±ì‹ í•˜ì§€ ì•ŠìŒ(3 + 2)
  - C ìµœì†Œ ë¹„ìš©: ê°±ì‹ í•˜ì§€ ì•ŠìŒ(3 + 0)
  - D ìµœì†Œ ë¹„ìš©: ê°±ì‹ í•˜ì§€ ì•ŠìŒ(3 + INF)
  - E ìµœì†Œ ë¹„ìš©: ê°±ì‹ í•˜ì§€ ì•ŠìŒ(3 + INF)
- 5ë‹¨ê³„: ë…¸ë“œ Aì—ì„œ Dë¥¼ ê±°ì³ê°€ëŠ” ë°©ë²•ì€ ì—†ìœ¼ë¯€ë¡œ ê°±ì‹ í•˜ì§€ ì•ŠëŠ”ë‹¤.
- 6ë‹¨ê³„: ë…¸ë“œ Aì—ì„œ Eë¥¼ ê±°ì³ ê° ë…¸ë“œê¹Œì§€ ê°€ëŠ” ìµœì†Œ ë¹„ìš©ë„ ê°±ì‹ í•œë‹¤.
  - A ìµœì†Œ ë¹„ìš©: ê°±ì‹ í•˜ì§€ ì•ŠìŒ(-6 + INF)
  - B ìµœì†Œ ë¹„ìš©: ê°±ì‹ í•˜ì§€ ì•ŠìŒ(-6 + INF)
  - C ìµœì†Œ ë¹„ìš©: ê°±ì‹ í•˜ì§€ ì•ŠìŒ(-6 + 2)
  - D ìµœì†Œ ë¹„ìš©: ê°±ì‹ í•˜ì§€ ì•ŠìŒ(-6 + INF)
  - E ìµœì†Œ ë¹„ìš©: ê°±ì‹ í•˜ì§€ ì•ŠìŒ(-6 + INF)
- 7ë‹¨ê³„: ì´ì œ 1ë‹¨ê³„ì—ì„œ 6ë‹¨ê³„ë¥¼ ë…¸ë“œ ê°œìˆ˜ - 1ë²ˆ ë°˜ë³µí•œë‹¤.

![Image]({{ site.url }}{{ site.baseurl }}/images/algorithm/algorithm-theory/2025-04-06-graph-bellman-ford/01.png){: .align-center}

## 5. ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜ì—ì„œì˜ ë°˜ë³µ

### 5.1. ë…¸ë“œ ê°œìˆ˜ - 1ë²ˆ ë°˜ë³µ

> ë§¤ ë°˜ë³µë§ˆë‹¤ ëª¨ë“  ê°„ì„ ì„ í™•ì¸í•˜ì—¬ ìµœì†Œ ë¹„ìš©ì„ ê°±ì‹ í•œë‹¤. ë°˜ë³µí•  ë•Œë§ˆë‹¤ ìµœë‹¨ ê²½ë¡œê°€ 1ê°œì”© í™•ì •ëœë‹¤.

### 5.2. ìŒìˆ˜ ì‚¬ì´í´ ì²´í¬

> ë…¸ë“œ ê°œìˆ˜ - 1ë²ˆ ë°˜ë³µ í›„ í•œ ë²ˆ ë” ë°˜ë³µì„ í•œë‹¤. ë§ˆì§€ë§‰ ë°˜ë³µì—ì„œ ìµœì†Œ ë¹„ìš©ì´ ê°±ì‹ ë˜ëŠ” ê²½ìš° ìŒìˆ˜ ì‚¬ì´í´ì´ ì¡´ìž¬í•œë‹¤ëŠ” ì˜ë¯¸ì´ë‹¤.

- ì•„ëž˜ ê·¸ë¦¼ì²˜ëŸ¼ ê³„ì† ìˆœí™˜í–ˆì„ ë•Œ ìµœë‹¨ ê²½ë¡œê°€ ê³„ì† ê°±ì‹ ëœë‹¤ë©´ ì‹¤ì§ˆì ìœ¼ë¡œ ìµœë‹¨ ê²½ë¡œëŠ” êµ¬í•  ìˆ˜ ì—†ê²Œ ëœë‹¤. 
  - ì´ë¥¼ ì°¾ìœ¼ë ¤ë©´ ì •ì  ê°œìˆ˜ë§Œí¼ì€ ë°˜ë³µ ì—°ì‚°í•´ì•¼ ì²´í¬ê°€ ê°€ëŠ¥í•˜ë‹¤.
- **ê·¸ëž˜í”„ì— ìŒì˜ ìˆœí™˜ì´ ìžˆìœ¼ë©´ ì–´ë–¤ ì•Œê³ ë¦¬ì¦˜ë„ ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•  ìˆ˜ ì—†ë‹¤.**
  - ë²¨ë§Œ í¬ë“œ ì•Œê³ ë¦¬ì¦˜ì€ ì´ëŸ° ìŒì˜ ìˆœí™˜ë„ ì°¾ì•„ë‚¼ ìˆ˜ ìžˆëŠ” ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.

![Image]({{ site.url }}{{ site.baseurl }}/images/algorithm/algorithm-theory/2025-04-06-graph-bellman-ford/02.png){: .align-center}

## 6. ðŸ“ ì½”ë“œ êµ¬í˜„

```
    0
   / \
  1---2    ê°€ì¤‘ì¹˜ ì˜ˆì‹œ:
 /|\     0->1: 4, 0->2: 2, 1->2: 3
3 4 5    1->3: 1, 1->4: 5, 1->5: 2
```

### 6.1. C++

{% raw %}
```cpp
#include <iostream>
#include <vector>
#include <limits>

void bellman_ford(size_t start, const std::vector<std::vector<std::pair<size_t, long long>>>& graph, size_t n) {
    std::vector<long long> dist(n, std::numeric_limits<long long>::max());
    dist[start] = 0;

    // n-1ë²ˆ ë°˜ë³µ
    for (size_t i = 1; i < n; i++) {
        for (size_t u = 0; u < n; u++) {
            for (auto [v, weight] : graph[u]) {
                if (dist[u] != std::numeric_limits<long long>::max() && dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight;
                }
            }
        }
    }

    // ìŒìˆ˜ ì‚¬ì´í´ ì²´í¬
    for (size_t u = 0; u < n; u++) {
        for (auto [v, weight] : graph[u]) {
            if (dist[u] != std::numeric_limits<long long>::max() && dist[u] + weight < dist[v]) {
                std::cout << "Negative weight cycle detected!\n";
                return;
            }
        }
    }

    // ê²°ê³¼ ì¶œë ¥
    for (size_t i = 0; i < n; i++) {
        std::cout << "Node " << i << ": ";
        if (dist[i] == std::numeric_limits<long long>::max())
            std::cout << "INF\n";
        else
            std::cout << dist[i] << "\n";
    }
}

int main() {
    size_t v = 6; // ë…¸ë“œ ìˆ˜
    std::vector<std::vector<std::pair<size_t, long long>>> graph(v);

    // ê·¸ëž˜í”„ ì •ì˜ (ë…¸ë“œ, {ì—°ê²°ëœ ë…¸ë“œ, ê°€ì¤‘ì¹˜})
    graph[0] = {{1, 4}, {2, 2}};
    graph[1] = {{2, 3}, {3, 1}, {4, 5}, {5, 2}};
    graph[2] = {{1, 3}};
    graph[3] = {{1, 1}};
    graph[4] = {{1, 5}};
    graph[5] = {{1, 2}};

    bellman_ford(0, graph, v);  // ì‹œìž‘ ë…¸ë“œ: 0
    return 0;
}
```
{% endraw %}

### 6.2. Python

```python
import heapq
from typing import List, Dict, Set
from collections import defaultdict

def bellman_ford(start: int, graph: Dict[int, List[tuple]], V: int) -> Dict[int, int]:
    # ê±°ë¦¬ ì €ìž¥ ë”•ì…”ë„ˆë¦¬ ì´ˆê¸°í™”
    distances = {node: float('inf') for node in range(V)}
    distances[start] = 0

    # V-1ë²ˆ ë°˜ë³µ
    for _ in range(V - 1):
        for u in range(V):
            for next_node, weight in graph[u]:
                if distances[u] != float('inf') and distances[u] + weight < distances[next_node]:
                    distances[next_node] = distances[u] + weight

    # ìŒìˆ˜ ì‚¬ì´í´ ì²´í¬
    for u in range(V):
        for next_node, weight in graph[u]:
            if distances[u] != float('inf') and distances[u] + weight < distances[next_node]:
                print("Negative weight cycle detected!")
                return

    # ê²°ê³¼ ì¶œë ¥
    for node in range(V):
        print(f"Node {node}: {distances[node] if distances[node] != float('inf') else 'INF'}")

    return distances

if __name__ == "__main__":
    V = 6  # ë…¸ë“œ ìˆ˜
    # ê·¸ëž˜í”„ ì •ì˜ (ë…¸ë“œ: [(ì—°ê²°ëœ ë…¸ë“œ, ê°€ì¤‘ì¹˜)])
    graph = {
        0: [(1, 4), (2, 2)],
        1: [(2, 3), (3, 1), (4, 5), (5, 2)],
        2: [(1, 3)],
        3: [(1, 1)],
        4: [(1, 5)],
        5: [(1, 2)]
    }

    bellman_ford(0, graph, V)  # ì‹œìž‘ ë…¸ë“œ: 0
```