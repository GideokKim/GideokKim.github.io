---
title: "[ìˆ˜í•™] FFTì™€ NTT (Fast Fourier Transform & Number Theoretic Transform)"
date: 2025-07-03 22:50:00 +0900
last_modified_at: 2025-07-03 22:50:00 +0900
categories:
  - Mathematics Theory
tags:
  - ìˆ˜í•™
  - mathematics
  - FFT
  - NTT
  - Fast Fourier Transform
  - Number Theoretic Transform
  - ì•Œê³ ë¦¬ì¦˜
  - algorithm
  - ë‹¤í•­ì‹ ê³±ì…ˆ
  - polynomial multiplication

toc: true
toc_sticky: true
---

## ğŸ’¡ FFTì™€ NTT ê°œìš”

> FFT(Fast Fourier Transform)ì™€ NTT(Number Theoretic Transform)ëŠ” ë‹¤í•­ì‹ ê³±ì…ˆì„ ë¹ ë¥´ê²Œ ìˆ˜í–‰í•˜ê¸° ìœ„í•œ ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.

ë‘ ë‹¤í•­ì‹ì˜ ê³±ì…ˆì„ naiveí•˜ê²Œ êµ¬í˜„í•˜ë©´ $O(N^2)$ì˜ ì‹œê°„ ë³µì¡ë„ê°€ í•„ìš”í•˜ì§€ë§Œ, FFTë‚˜ NTTë¥¼ ì‚¬ìš©í•˜ë©´ $O(N \log N)$ì˜ ì‹œê°„ ë³µì¡ë„ë¡œ í•´ê²°í•  ìˆ˜ ìˆë‹¤.

## ğŸ¯ ì•Œê³ ë¦¬ì¦˜ì˜ ëª©ì 

- í° ìˆ˜ì˜ ê³±ì…ˆì„ ë¹ ë¥´ê²Œ ìˆ˜í–‰
- ë‹¤í•­ì‹ ê³±ì…ˆì˜ íš¨ìœ¨ì ì¸ ê³„ì‚°
- ì‹ í˜¸ ì²˜ë¦¬ ë° ë°ì´í„° ë¶„ì„
- ë¬¸ìì—´ ë§¤ì¹­ ìµœì í™”

## ğŸ“š FFT (Fast Fourier Transform)

### 1. FFTì˜ ê¸°ë³¸ ì›ë¦¬

FFTëŠ” ë‹¤í•­ì‹ì„ ê³„ìˆ˜ í‘œí˜„(coefficient representation)ì—ì„œ ì ê°’ í‘œí˜„(point-value representation)ìœ¼ë¡œ ë³€í™˜í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.

ë‹¤í•­ì‹ $A(x) = a_0 + a_1x + a_2x^2 + ... + a_{n-1}x^{n-1}$ê°€ ìˆì„ ë•Œ:

1. ê³„ìˆ˜ í‘œí˜„: $[a_0, a_1, a_2, ..., a_{n-1}]$
2. ì ê°’ í‘œí˜„: $[(x_0, y_0), (x_1, y_1), ..., (x_{n-1}, y_{n-1})]$ where $y_i = A(x_i)$

### 2. FFTì˜ í•µì‹¬ ì•„ì´ë””ì–´

FFTëŠ” ë³µì†Œìˆ˜ ë‹¨ìœ„ê·¼(complex roots of unity)ì„ ì‚¬ìš©í•œë‹¤. nì°¨ ë‹¨ìœ„ê·¼ì€ ë‹¤ìŒê³¼ ê°™ë‹¤:

$\omega_n = e^{2\pi i/n}$

ì£¼ìš” ì„±ì§ˆ:
- $\omega_n^n = 1$
- $\omega_n^{k+n/2} = -\omega_n^k$

### 3. FFT êµ¬í˜„ì˜ í•µì‹¬ ë‹¨ê³„

```cpp
void fft(vector<complex<double>>& a, bool invert) {
    int n = a.size();
    if (n == 1) return;

    vector<complex<double>> a0(n/2), a1(n/2);
    for (int i = 0; 2 * i < n; i++) {
        a0[i] = a[2*i];
        a1[i] = a[2*i+1];
    }
    
    fft(a0, invert);
    fft(a1, invert);

    double ang = 2 * PI / n * (invert ? -1 : 1);
    complex<double> w(1), wn(cos(ang), sin(ang));
    
    for (int i = 0; 2 * i < n; i++) {
        a[i] = a0[i] + w * a1[i];
        a[i + n/2] = a0[i] - w * a1[i];
        if (invert) {
            a[i] /= 2;
            a[i + n/2] /= 2;
        }
        w *= wn;
    }
}
```

## ğŸ“š NTT (Number Theoretic Transform)

### 1. NTTì˜ íŠ¹ì§•

NTTëŠ” FFTì˜ ë³€í˜•ìœ¼ë¡œ, ë³µì†Œìˆ˜ ëŒ€ì‹  ëª¨ë“ˆëŸ¬ ì—°ì‚°ì„ ì‚¬ìš©í•œë‹¤. ì´ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì¥ì ì´ ìˆë‹¤:

- ì •ìˆ˜ë§Œ ì‚¬ìš©í•˜ë¯€ë¡œ ë¶€ë™ì†Œìˆ˜ì  ì˜¤ì°¨ê°€ ì—†ìŒ
- ëª¨ë“ˆëŸ¬ ì—°ì‚°ìœ¼ë¡œ ì˜¤ë²„í”Œë¡œìš° ë°©ì§€
- ë” ë¹ ë¥¸ ì—°ì‚° ì†ë„

### 2. NTTë¥¼ ìœ„í•œ ëª¨ë“ˆëŸ¬ì™€ ì›ì‹œê·¼

NTTë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œëŠ” ë‹¤ìŒ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ì†Œìˆ˜ $P$ì™€ ì›ì‹œê·¼ $g$ê°€ í•„ìš”í•˜ë‹¤:

- $P = c \cdot 2^k + 1$ í˜•íƒœì˜ ì†Œìˆ˜ (cëŠ” ì‘ì€ í™€ìˆ˜)
- $g$ëŠ” $P$ì˜ ì›ì‹œê·¼

ìì£¼ ì‚¬ìš©ë˜ëŠ” ê°’ë“¤:
- $P = 998244353 = 119 \cdot 2^{23} + 1$
- $g = 3$

### 3. NTT êµ¬í˜„

```cpp
const int MOD = 998244353;
const int ROOT = 3;

int power(int a, int n) {
    int ret = 1;
    while (n) {
        if (n & 1) ret = (1LL * ret * a) % MOD;
        a = (1LL * a * a) % MOD;
        n >>= 1;
    }
    return ret;
}

void ntt(vector<int>& a, bool invert) {
    int n = a.size();
    for (int i = 1, j = 0; i < n; i++) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1)
            j ^= bit;
        j ^= bit;
        if (i < j)
            swap(a[i], a[j]);
    }

    for (int len = 2; len <= n; len <<= 1) {
        int wlen = invert ? power(ROOT, MOD - 1 - (MOD - 1) / len)
                         : power(ROOT, (MOD - 1) / len);
        for (int i = 0; i < n; i += len) {
            int w = 1;
            for (int j = 0; j < len / 2; j++) {
                int u = a[i + j];
                int v = (1LL * a[i + j + len / 2] * w) % MOD;
                a[i + j] = (u + v) % MOD;
                a[i + j + len / 2] = (u - v + MOD) % MOD;
                w = (1LL * w * wlen) % MOD;
            }
        }
    }

    if (invert) {
        int n_inv = power(n, MOD - 2);
        for (int& x : a)
            x = (1LL * x * n_inv) % MOD;
    }
}
```

## ğŸ¨ ì‘ìš© ì˜ˆì œ

### 1. í° ìˆ˜ì˜ ê³±ì…ˆ

ë‘ í° ìˆ˜ Aì™€ Bì˜ ê³±ì…ˆì„ ìˆ˜í–‰í•  ë•Œ:
1. ê° ìˆ˜ë¥¼ ë‹¤í•­ì‹ìœ¼ë¡œ ë³€í™˜
2. FFT/NTTë¥¼ ì‚¬ìš©í•´ ë‹¤í•­ì‹ ê³±ì…ˆ
3. ê²°ê³¼ë¥¼ ë‹¤ì‹œ ìˆ˜ë¡œ ë³€í™˜

```cpp
vector<int> multiply(vector<int>& a, vector<int>& b) {
    int n = 1;
    while (n < a.size() + b.size())
        n <<= 1;
    a.resize(n);
    b.resize(n);
    
    ntt(a, false);
    ntt(b, false);
    
    for (int i = 0; i < n; i++)
        a[i] = (1LL * a[i] * b[i]) % MOD;
        
    ntt(a, true);
    return a;
}
```

### 2. ë¬¸ìì—´ ë§¤ì¹­

ë¬¸ìì—´ ë§¤ì¹­ì—ì„œ FFT/NTTë¥¼ í™œìš©í•˜ë©´ ì™€ì¼ë“œì¹´ë“œê°€ í¬í•¨ëœ íŒ¨í„´ ë§¤ì¹­ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì²˜ë¦¬í•  ìˆ˜ ìˆë‹¤.

## â“ ì£¼ì˜ì‚¬í•­ê³¼ íŒ

1. **ì •ë°€ë„ ë¬¸ì œ**
   - FFTëŠ” ë¶€ë™ì†Œìˆ˜ì  ì—°ì‚°ì„ ì‚¬ìš©í•˜ë¯€ë¡œ ì •ë°€ë„ ì˜¤ì°¨ê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤.
   - ì •ë°€ë„ê°€ ì¤‘ìš”í•œ ê²½ìš° NTTë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.

2. **ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰**
   - ì…ë ¥ í¬ê¸°ì˜ 2ì˜ ê±°ë“­ì œê³±ê¹Œì§€ íŒ¨ë”©ì´ í•„ìš”í•˜ë‹¤.
   - í° ì…ë ¥ì˜ ê²½ìš° ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì— ì£¼ì˜ê°€ í•„ìš”í•˜ë‹¤.

3. **ìµœì í™” íŒ**
   - ì‘ì€ í¬ê¸°ì˜ ì…ë ¥ì—ëŠ” ì¼ë°˜ì ì¸ ê³±ì…ˆì´ ë” ë¹ ë¥¼ ìˆ˜ ìˆë‹¤.
   - ë³‘ë ¬í™”ê°€ ê°€ëŠ¥í•œ êµ¬ì¡°ì´ë¯€ë¡œ í•„ìš”ì‹œ ë³‘ë ¬ ì²˜ë¦¬ë¥¼ ê³ ë ¤í•œë‹¤.

## ğŸ” ì°¸ê³  ìë£Œ

- [CP-Algorithms - FFT](https://cp-algorithms.com/algebra/fft.html)
